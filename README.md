# Тестовое задание

## Тестовое задание №1
Для того чтобы поменять байты местами, используется следующий алгоритм:
1. Отделяем первый байт с помощью побитового И с числом 65280 (11111111 00000000)
2. Отделяем второй байт с помощью побитового И с числом 255 (00000000 11111111)
3. Сдвигаем второй байт на восемь бит влево
4. Сдвигаем первый байт на восемь бит вправо
5. Получаем нужное число с помощью побитового ИЛИ для второго и первого байта

Пример с числом 65000:

Двоичное представление 11111101 11101000

Первый байт 11111101 11101000 & 11111111 00000000 = 11111101 00000000  
Второй байт 11111101 11101000 & 00000000 11111111 = 00000000 11101000

Сдвигаем второй байт на восемь бит влево: 00000000 11101000 << 8 = 11101000 00000000   
Сдвигает первый байт на восемь бит вправо: 11111101 00000000 >> 8 = 00000000 11111101  

Получаем нужное число с помощью побитового ИЛИ: 11101000 00000000 | 00000000 11111101 = 11101000 11111101  

## Тестовое задание №2

Аналитическое решение: 

Сначала посчитаем вес, если бы во всех корзинах были настоящие монеты:  
S = w + 2w + ... + tw + ... + (N-1)w = N(N-1)w/2 (Используем формулу суммы арифметической прогрессии)

Предположим, что в некоторой корзине t находятся фальшивые монеты. Тогда общая сумма будет выглядеть следующим
образом:  
w + 2w + ... + tw - td + ... + (N-1)w = S - td = P  

Из этой формулы следует что номер t можно найти следующим образом:  
t = (S - P) / d

Если S = P значит фальшивые монеты находятся в той корзине, из которой не брали монеты. То есть N

## Тестовое задание №3

Вывод:
```json
{
    "W": 13,
    "e": 485,
    "l": 167,
    "c": 147,
    "o": 406,
    "m": 119,
    " ": 698,
    "t": 428,
    "P": 104,
    "y": 133,
    "h": 149,
    "n": 402,
    ".": 40,
    "r": 286,
    "g": 73,
    "N": 20,
    "i": 317,
    ":": 18,
    "J": 4,
    "a": 292,
    "v": 62,
    "S": 71,
    "p": 119,
    "s": 278,
    "f": 77,
    "w": 62,
    "b": 50,
    ",": 57,
    "u": 164,
    "d": 127,
    "x": 16,
    "k": 33,
    "▼": 1,
    "C": 31,
    "F": 21,
    "D": 34,
    "I": 29,
    "▲": 3,
    "T": 18,
    "≡": 1,
    "M": 17,
    "G": 23,
    "O": 8,
    "A": 39,
    "L": 26,
    "R": 10,
    "z": 1,
    "Q": 7,
    "H": 8,
    "B": 19,
    "/": 9,
    "V": 2,
    "'": 39,
    "-": 30,
    "E": 32,
    "U": 13,
    ">": 73,
    "_": 3,
    "#": 9,
    "3": 39,
    "(": 20,
    ")": 20,
    "\r": 14,
    "\n": 14,
    "=": 9,
    "0": 38,
    "1": 23,
    "<": 1,
    "+": 2,
    "2": 44,
    "5": 8,
    "8": 7,
    "4": 11,
    "9": 3,
    "7": 8,
    "6": 17,
    " ": 5,
    "[": 5,
    "]": 5,
    "*": 4,
    ";": 1,
    "Y": 1,
    "’": 3,
    "—": 2,
    "\"": 2,
    "!": 4,
    "?": 3,
    "\\": 1,
    "{": 1,
    "}": 1,
    "&": 3,
    "q": 2,
    "j": 4,
    "K": 2,
    "…": 1,
    "©": 1
}
```

## Тестовое задание №4
Для того чтобы найти все поля "updated" и поменять значение на текущие дату и время в формате ISO 8601
рекурсивно обходим словарь, заменяя все значения полей "updated".

